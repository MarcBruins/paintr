---
phase: 01-foundation
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - .github/workflows/ci.yml
  - vercel.json
autonomous: false
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04
  - AUTH-05
  - AUTH-06
must_haves:
  truths:
    - "CI pipeline runs lint, type-check, and build on every push"
    - "Application deploys successfully to a production Vercel URL"
    - "All auth flows work on the production deployment"
    - "RLS isolation is confirmed — Org A data invisible to Org B"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline"
      contains: "biome check"
    - path: "vercel.json"
      provides: "Vercel deployment configuration (if needed)"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "package.json"
      via: "pnpm lint and build scripts"
      pattern: "pnpm.*lint|pnpm.*build"
---

<objective>
Set up GitHub Actions CI pipeline and deploy the application to Vercel production. Then perform a comprehensive end-to-end verification of all Phase 1 requirements on the live deployment.

Purpose: This delivers the final Phase 1 success criterion: "The application deploys successfully to a production URL and CI runs on every commit." The checkpoint verifies all 6 AUTH requirements are met on the live system.
Output: CI pipeline running on GitHub, live Vercel deployment URL, all Phase 1 requirements verified.
</objective>

<execution_context>
@C:/Users/MarcBruins/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/MarcBruins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions CI pipeline and deploy to Vercel</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
    1. Create `.github/workflows/ci.yml`:
       ```yaml
       name: CI

       on:
         push:
           branches: [main]
         pull_request:
           branches: [main]

       jobs:
         lint-and-build:
           runs-on: ubuntu-latest
           steps:
             - uses: actions/checkout@v4
             - uses: pnpm/action-setup@v4
               with:
                 version: 9
             - uses: actions/setup-node@v4
               with:
                 node-version: 22
                 cache: pnpm
             - run: pnpm install --frozen-lockfile
             - run: pnpm lint
             - run: pnpm exec tsc --noEmit
             - run: pnpm build
               env:
                 DATABASE_URL: ${{ secrets.DATABASE_URL }}
                 DATABASE_URL_DIRECT: ${{ secrets.DATABASE_URL_DIRECT }}
                 BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
                 BETTER_AUTH_URL: ${{ secrets.BETTER_AUTH_URL }}
                 NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
                 RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
       ```

    2. Deploy to Vercel using the Vercel CLI:
       ```bash
       pnpm add -g vercel
       vercel --yes
       ```
       If Vercel CLI is already installed globally, skip the install step.

       If authentication is needed, a checkpoint will be created dynamically.

    3. After initial deployment, link the project and set environment variables on Vercel:
       ```bash
       vercel env add DATABASE_URL production
       vercel env add DATABASE_URL_DIRECT production
       vercel env add BETTER_AUTH_SECRET production
       vercel env add BETTER_AUTH_URL production
       vercel env add NEXT_PUBLIC_APP_URL production
       vercel env add RESEND_API_KEY production
       vercel env add EMAIL_FROM production
       ```
       Note: The user will need to provide the actual values for each env var. `BETTER_AUTH_URL` and `NEXT_PUBLIC_APP_URL` should be the Vercel production URL (e.g., `https://paintr.vercel.app`).

    4. Trigger a production deploy:
       ```bash
       vercel --prod
       ```

    5. Create `vercel.json` only if custom configuration is needed (e.g., rewrites, headers). For a standard Next.js 16 app, Vercel auto-detects the framework and no config file is needed. Only create if the deploy fails without it.

    6. Push the CI workflow to GitHub and verify the pipeline runs:
       ```bash
       git add .github/workflows/ci.yml
       git commit -m "ci: add GitHub Actions pipeline for lint, type-check, and build"
       git push
       ```
       Check GitHub Actions tab to confirm the workflow runs successfully.
  </action>
  <verify>
    1. GitHub Actions CI workflow runs and passes (lint + type-check + build)
    2. `vercel --prod` succeeds and outputs a production URL
    3. Visiting the production URL shows the Paintr application
  </verify>
  <done>CI pipeline runs on every push, production deployment is live on Vercel with all environment variables configured.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify all Phase 1 requirements on production deployment</name>
  <files></files>
  <action>
    Present the user with a comprehensive verification checklist for the production deployment.

    This is a human-verify checkpoint — no automated action is needed. The user tests the live production URL.

    What was built: Complete Phase 1 foundation — user authentication, organization management, role-based access, RLS tenant isolation, CI pipeline, and production deployment.
  </action>
  <verify>
    The user tests all 6 AUTH requirements on the PRODUCTION deployment URL:

    **AUTH-01 + AUTH-02 (Account + Session):**
    1. Visit the production URL /sign-up
    2. Create a new account with email and password
    3. Confirm you land on the dashboard
    4. Close the browser tab completely
    5. Reopen the production URL — you should still be signed in (session persists)

    **AUTH-03 (Create/Join Organization):**
    6. Navigate to /create-org
    7. Create an organization named "Test Painting Co."
    8. Confirm the dashboard shows your organization name

    **AUTH-04 (Invite Members):**
    9. On the dashboard, enter a second email address in the invite form
    10. Select "estimator" role and send the invitation
    11. Check the second email inbox for the invitation email

    **AUTH-03 + AUTH-06 (Join + Role):**
    12. Open an incognito/private browser window
    13. Click the invitation link from the email
    14. Sign up as the second user if needed, then accept the invitation
    15. Confirm the second user sees the dashboard with the same organization
    16. Confirm the second user's role is "estimator"

    **AUTH-05 (Shared quotes within org — data isolation):**
    17. This is a structural verification — the quotes table has RLS enabled with org_isolation policy
    18. Verify in Supabase Dashboard -> Table Editor -> quotes -> RLS Policies that "org_isolation" policy exists
    19. Verify RLS is enabled (toggle should be ON)

    **CI:**
    20. Check GitHub Actions tab — most recent push should show a passing CI run
  </verify>
  <done>User confirms all 6 AUTH requirements work on production. Type "approved" if all checks pass, or describe any issues found.</done>
</task>

</tasks>

<verification>
1. Production URL loads and shows the Paintr application
2. Full sign-up -> sign-in -> create-org -> invite -> accept flow works on production
3. GitHub Actions CI pipeline passes on latest push
4. RLS policy visible in Supabase dashboard for quotes table
5. Session persists across browser close and reopen
</verification>

<success_criteria>
The application is deployed to production, CI runs on every commit, and all Phase 1 success criteria from the roadmap are met: account creation, session persistence, organization management, invitation flow, role-based access, and RLS tenant isolation.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
